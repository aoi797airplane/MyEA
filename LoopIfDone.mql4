//+------------------------------------------------------------------+
//|                                                   LoopIfDone.mq4 |
//|                                                     Aoi Morimoto |
//|                                         https://fx-libraries.com/|
//+------------------------------------------------------------------+
#include <stdlib.mqh>
#property copyright "Aoi Morimoto"
#property link      "https://fx-libraries.com/"
#property description "Loop If Done Expert Advisor"
#property version   "1.01"
#property strict
#define MAGICMA  20201015
//--- Inputs
input double TakeProfit     =500;
input double Lots           =0.1;
input double MinimumLots    =0.01;
input double TrailingStop   =200;
input double MaximumRisk    =0.02;
input double DecreaseFactor =3;

input int    MaximumPosition=3;
input double PriceRange     =15;
input string x="損切りあり(推奨):0, 損切りなし:1";
input int    LossCut        =0;
double tmp_array[][2];

//+------------------------------------------------------------------+
//| Expert initialization function                                   |
//+------------------------------------------------------------------+
int OnInit()
{
    int PositionCount,OrderCount;
    double LossCutPoint      = PriceRange*3;
    double NowPositionPrices = ArrayResize(tmp_array,MaximumPosition);
    double NowOrderPrices    = ArrayResize(tmp_array,MaximumPosition);
    double OldPositionPrices = ArrayResize(tmp_array,MaximumPosition);
    double OldOrderPrices    = ArrayResize(tmp_array,MaximumPosition);
    
    return(INIT_SUCCEEDED);
}
//+------------------------------------------------------------------+
//| Calculate open positions                                         |
//+------------------------------------------------------------------+
int CalculateCurrentOrders(string symbol)
  {
   int buys=0,sells=0;
//---
   for(int i=0;i<OrdersTotal();i++)
     {
      if(OrderSelect(i,SELECT_BY_POS,MODE_TRADES)==false) break;
      if(OrderSymbol()==Symbol() && OrderMagicNumber()==MAGICMA)
        {
         if(OrderType()==OP_BUY)  buys++;
         if(OrderType()==OP_SELL) sells++;
        }
     }
//--- return orders volume
   if(buys>0) return(buys);
   else       return(-sells);
  }
//+------------------------------------------------------------------+
//| Calculate optimal lot size                                       |
//+------------------------------------------------------------------+
double LotsOptimized()
  {
   double lot=Lots;
   int    orders=OrdersHistoryTotal();     // history orders total
   int    losses=0;                  // number of losses orders without a break
    //--- select lot size
    //---
   
    //--- calculate number of losses orders without a break
   if(DecreaseFactor>0)
     {
      for(int i=orders-1;i>=0;i--)
        {
         if(OrderSelect(i,SELECT_BY_POS,MODE_HISTORY)==false)
           {
            Print("Error in history!");
            break;
           }
         if(OrderSymbol()!=Symbol() || OrderType()>OP_SELL)
            continue;
         //---
         if(OrderProfit()>0) break;
         if(OrderProfit()<0) losses++;
        }
      if(losses>1)
         lot=NormalizeDouble(lot-lot*losses/DecreaseFactor,1);
     }
//--- return lot size
   if(lot<0.1) lot=0.1;
   return(lot);
  }
  
//+------------------------------------------------------------------+
//| Check for position and order                                     |
//+------------------------------------------------------------------+
void CheckForPosition()
{
    int PositionCount=0;
    int OrderCount=0;
    double MaxOpenPrice,MinOpenPrice;
    
    ArrayCopy(NowPositionPrices,OldPositionPrices);
    ArrayCopy(NowOrderPrices,OldOrderPrices);

    ArrayInitializer(NowPositionPrices,0);
    ArrayInitializer(NowOrderPrices,0);

    for(int i=OrdersHistoryTotal()-1;i>=0;i--)
    {
        if(OrderSelect(i,SELECT_BY_POS)==false) break;
        if(OrderSymbol() != Symbol() || OrderMagicNumber() != MAGICMA) continue;

        if(OrderType() == OP_BUY)
        {
            NowPositionPrices[PositionCount] = {OrderOpenPrice(),OrderTicket()};
            PositionCount++;
        }
        if(OrderType() == OP_BUYLIMIT)
        {
            NowOrderPrices[OrderCount] = {OrderOpenPrice(),OrderTicket()};
            OrderCount++;
        }
    }

    ArraySort(NowPositionPrices,WHOLE_ARRAY,0,MODE_DESCEND);
    ArraySort(NowOrderPrices,WHOLE_ARRAY,0,MODE_DESCEND);

}
//+------------------------------------------------------------------+
//| Check for open order conditions                                  |
//+------------------------------------------------------------------+
void CheckForOpen()
{
    int    res;
    //--- go trading only for first tiks of new bar
    if(Volume[0]>1) return;
    
    //---ポジションを保有していない
    if(PositionCount == 0)
    {
        //--- first buy action
        if(OrderCount == 0)
        {
            res=OrderSend(Symbol(),OP_BUY,LotsOptimized(),Ask,3,Ask-LossCutPoint*Point,Ask+PriceRange*Point,"LoopIfDone",MAGICMA,0,Blue);
            if(res != -1)
            {
                int err = GetLastError();
                printf("[OrderSendError] : " , err , " ", ErrorDescription(err));
                printf("LoopIfDone 自動売買プログラムを開始できません")
                
                return;
            }
            
            FollowPositionOrder(MaximumPosition-1);
            printf("LoopIfDone 自動売買プログラムを開始しました")
            
            return;
        }

        else
        {
            res=OrderSend(Symbol(),OP_BUY,LotsOptimized(),Ask,3,Ask-LossCutPoint*Point,Ask+PriceRange*Point,"LoopIfDone",MAGICMA,0,Blue);
            if(res != -1)
            {
                int err = GetLastError();
                Print("[OrderSendError] : " , err , " ", ErrorDescription(err));
            }

            allOrderDelete();
            FollowPositionOrder(MaximumPosition-1);

            return;
        }

    }

    //--- ポジションを最大で持っている
    if(PositionCount == MaximumPosition)
    {
        allOrderDelete();
        return;
    }

    //--- 直前の決済が損切りだった
    //このTickで行われた注文かどうかを判定する必要あり。
    OrderSelect(OrdersHistoryTotal()-1,SELECT_BY_POS,MODE_HISTORY);
    if(OrderProfit() < 0)
    {
        OrderSend(Symbol(),OP_BUY,LotsOptimized(),Ask,3,Ask-LossCutPoint*Point,Ask+PriceRange*Point,"LoopIfDone",MAGICMA,0,Blue);
    }

    else
    {
        for(int i=0;i<MaximumPosition;i++)
        {
            if(NowPositionPrices[i]==OldPositionPrices[i]) continue;
            else
            {
                
            }
        }
    }

}
//+------------------------------------------------------------------+
//| Check for close order conditions                                 |
//+------------------------------------------------------------------+
void CheckForClose()
  {
//--- go trading only for first tiks of new bar
   if(Volume[0]>1) return;
   //エラーが出ないように変える必要あり
//---
   for(int i=OrdersHistoryTotal-1;i>=0;i--)
     {
      if(OrderSelect(i,SELECT_BY_POS,MODE_TRADES)==false) break;
      if(OrderMagicNumber()!=MAGICMA || OrderSymbol()!=Symbol()) continue;
      //--- check order type
      if(OrderType()==OP_BUY)
        {
         if(Bid-OrderOpenPrice()>Ask-Bid && iRSI(NULL,0,GPeriod,PRICE_MEDIAN,0)>70)
           {
            if(!OrderClose(OrderTicket(),OrderLots(),Bid,3,White))
               Print("OrderClose error ",GetLastError());
           }
         if(MathAbs(Bid-OrderOpenPrice())>OrderOpenPrice()*LossCutPoint)
           {
            if(!OrderClose(OrderTicket(),OrderLots(),Bid,3,White))
               Print("OrderClose error ",GetLastError());
           }
         if(TrailingStop>0)
           {
            if(Bid-OrderOpenPrice()>Point*TrailingStop)
              {
               if(OrderStopLoss()<Bid-Point*TrailingStop)
                 {
                  //--- modify order and exit
                  if(!OrderModify(OrderTicket(),OrderOpenPrice(),Bid-Point*TrailingStop,OrderTakeProfit(),0,Green))
                     Print("OrderModify error ",GetLastError());
                  return;
                 }
              }
           }
         break;
        }
      if(OrderType()==OP_SELL)
        {
         if(OrderOpenPrice()-Ask>Ask-Bid && iRSI(NULL,0,GPeriod,PRICE_MEDIAN,0)<30)
           {
            if(!OrderClose(OrderTicket(),OrderLots(),Ask,3,White))
               Print("OrderClose error ",GetLastError());
           }
         if(MathAbs(OrderOpenPrice()-Ask)>OrderOpenPrice()*LossCutPoint)
           {
            if(!OrderClose(OrderTicket(),OrderLots(),Bid,3,White))
               Print("OrderClose error ",GetLastError());
           }
         if(TrailingStop>0)
           {
            if((OrderOpenPrice()-Ask)>(Point*TrailingStop))
              {
               if((OrderStopLoss()>(Ask+Point*TrailingStop)) || (OrderStopLoss()==0))
                 {
                  //--- modify order and exit
                  if(!OrderModify(OrderTicket(),OrderOpenPrice(),Ask+Point*TrailingStop,OrderTakeProfit(),0,Red))
                     Print("OrderModify error ",GetLastError());
                  return;
                 }
              }
           }
         break;
        }
     }
  }
//+------------------------------------------------------------------+
//| OnTick function                                                  |
//+------------------------------------------------------------------+
void OnTick()
  {
//--- check for history and trading
   if(Bars<100 || IsTradeAllowed()==false)
      return;
//--- calculate open orders by current symbol
   CheckForOpen();
//---
  }
//+------------------------------------------------------------------+
int MyOrderSend(
    int IsLossCut,
    string   symbol,
    int      cmd,
    double   volume,
    double   price,
    int      slippage,
    double   stoploss,
    double   takeprofit,
    string   comment     = NULL,
    int      magic       = 0,
    datetime expiration  = 0,
    color    arrow_color = clrNONE
    )
    {
        int res;
        if(IsLossCut == 0)//損切りあり
        {
            res=OrderSend(Symbol(),OP_BUY,LotsOptimized(),Ask,3,Ask-LossCutPoint*Point,Ask+PriceRange*Point,"LoopIfDone",MAGICMA,0,Blue);
            return res;
        }
        else
        {
            printf("MyOrderSend function error occured.");
            return -1;
        }

        else if(IsLossCut == 1)//損切りなし
        {
            res=OrderSend(Symbol(),OP_BUY,LotsOptimized(),Ask,3,0,Ask+PriceRange*Point,"LoopIfDone",MAGICMA,0,Blue);
            return res;
        }
    }

void allOrderDelete()
{
    for(int i=OrdersHistoryTotal()-1; i>=0; i--)
    {
        if(OrderSelect(i,SELECT_BY_POS)==false) break;
        if(OrderSymbol()!=Symbol() || OrderMagicNumber()!=aMagic) continue;

        int type=OrderType();
        if(type==OP_BUY || type==OP_SELL) continue;

        int ticket=OrderTicket();
        if(orderDeleteReliable(ticket)==false);
        {
            Print("allOrderDelete: Ticket #",ticket,", failed to delete");
        }
    }
}

void FollowPositionOrder(int OrderNum)
{
    for(int i=1;i<=OrderNum;i++)
    {
        res=OrderSend(Symbol(),OP_BUYLIMIT,LotsOptimized(),Ask-i*PriceRange*Point,3,Ask-i*PriceRange*Point-LossCutPoint*Point,Ask-i*PriceRange*Point+PriceRange*Point,"LoopIfDone",MAGICMA,0,Blue);
        if(res != -1)
        {
            int err = GetLastError();
            Print("[OrderSendError] : " , err , " ", ErrorDescription(err));
        }
    }
    
}